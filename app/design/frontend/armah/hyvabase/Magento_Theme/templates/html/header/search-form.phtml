<?php

declare(strict_types=1);

use Magento\Framework\Escaper;
use Magento\Framework\View\Element\Template;
use Magento\Search\Helper\Data as SearchHelper;
use Hyva\Theme\ViewModel\HeroiconsOutline;
use Hyva\Theme\Model\ViewModelRegistry;

/** @var Escaper $escaper */
/** @var Template $block */
/** @var ViewModelRegistry $viewModels */
/** @var SearchHelper $helper */

$helper = $this->helper(SearchHelper::class);

/** @var HeroiconsOutline $heroicons */
$heroicons = $viewModels->require(HeroiconsOutline::class);

function cleanPlaceholderContent(string $content): string
{
    $content = preg_replace('/<style\b[^>]*>(.*?)<\/style>/is', '', $content);
    $content = preg_replace('/<div\b[^>]*>(.*?)<\/div>/is', '$1', $content);
    $content = strip_tags($content);
    return trim($content);
}

$placeholder1 = cleanPlaceholderContent($block->getLayout()->createBlock('Magento\Cms\Block\Block')->setBlockId('1-placeholder-search')->toHtml());
$placeholder2 = cleanPlaceholderContent($block->getLayout()->createBlock('Magento\Cms\Block\Block')->setBlockId('2-placeholder-search')->toHtml());
?>

<script>
    'use strict';

    function initMiniSearch() {
        return {
            minSearchLength: <?= (int) $helper->getMinQueryLength() ?>,
            suggestions: [],
            placeholders: [
                <?= json_encode($placeholder1) ?>,
                <?= json_encode($placeholder2) ?>
            ],
            currentPlaceholderIndex: 0,
            typingEffectText: '',
            typingIndex: 0,
            deleting: false,
            paused: false,
            initTypingEffect() {
                this.$nextTick(() => {
                    this.updatePlaceholder();
                    setInterval(() => {
                        if (!this.paused) {
                            this.updatePlaceholder();
                        }
                    }, 100);
                });
            },
            updatePlaceholder() {
                if (!this.$refs.searchInput) return;

                const fullText = this.placeholders[this.currentPlaceholderIndex];

                if (!this.deleting && this.typingIndex < fullText.length) {
                    this.typingEffectText += fullText[this.typingIndex];
                    this.typingIndex++;
                } else if (!this.deleting && this.typingIndex === fullText.length) {
                    this.paused = true;
                    setTimeout(() => {
                        this.deleting = true;
                        this.paused = false;
                    }, 1500);
                } else if (this.deleting && this.typingIndex > 0) {
                    this.typingIndex--;
                    this.typingEffectText = fullText.substring(0, this.typingIndex);
                } else if (this.deleting && this.typingIndex === 0) {
                    this.deleting = false;
                    this.currentPlaceholderIndex = (this.currentPlaceholderIndex + 1) % this.placeholders.length;
                }

                this.$refs.searchInput.setAttribute('placeholder', this.typingEffectText);
            },

            suggest() {
                const search = this.$refs.searchInput;
                if (search.value.length >= this.minSearchLength) {
                    search.setCustomValidity('');
                    search.reportValidity();
                    this.fetchSuggestions(search.value);
                } else {
                    this.suggestions = [];
                }
            },
            fetchSuggestions(term) {
                fetch(window.BASE_URL + 'search/ajax/suggest?' + new URLSearchParams({
                        q: term
                    }), {
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    })
                    .then(response => {
                        if (!response.ok) throw new Error('Network response was not ok');
                        return response.json();
                    })
                    .then(result => this.suggestions = result)
                    .catch(error => {
                        console.error('Error fetching suggestions:', error);
                        this.suggestions = [];
                    });
            },
            search(term) {
                const search = this.$refs.searchInput;
                term = term || search.value;
                if (term.length < this.minSearchLength) {
                    search.setCustomValidity('<?= $escaper->escapeJs(
                                                    __('Minimum Search query length is %1', $helper->getMinQueryLength())
                                                ) ?>');
                    search.reportValidity();
                } else {
                    search.setCustomValidity('');
                    search.value = term;
                    this.$refs.form.submit();
                }
            },
            focusElement(element) {
                if (element && element.nodeName === "DIV") {
                    element.focus();
                    return true;
                } else {
                    return false;
                }
            }
        }
    }
</script>

<search x-data="initMiniSearch()" x-init="initTypingEffect()">
    <form class="form minisearch relative p-0 bg-transparent" id="search_mini_form" x-ref="form" @submit.prevent="search()"
        action="<?= $escaper->escapeUrl($helper->getResultUrl()) ?>" method="get">

        <!-- <div class="block lg:hidden"><?php //TODO echo  $heroicons->searchHtml('stroke-1', 26, 26, ['aria-hidden' => 'true']); ?></div> -->

        <div class="rounded-t-[5px] lg:rounded-[10px] border-2 shadow-md flex pr-2 px-6_py-4 bg-primary lg:bg-transparent lg:p-0
                    bg-white border-[#f5f5f5] lg:w-full mx-auto
                    ">

            <input id="search"
                x-ref="searchInput"
                type="search"
                autocomplete="off"
                name="<?= $escaper->escapeHtmlAttr($helper->getQueryParamName()) ?>"
                value="<?=
                        /** @noEscape */
                        $helper->getEscapedQueryText() ?>"
                maxlength="<?= $escaper->escapeHtmlAttr($helper->getMaxQueryLength()) ?>"
                class="w-full
                        leading-5
                        py-2
                        pl-5 lg:pl-0
                        text-black
                        border-transparent
                        rounded-full
                        placeholder:text-[#BCBFC5] placeholder:text-[13px]
                        focus:ring-0
                        lg:order-1"

                @focus.once="suggest"
                @input.debounce.300="suggest"
                @keydown.arrow-down.prevent="focusElement($root.querySelector('[tabindex]'))"
                @search-open.window.debounce.10="$el.focus(); $el.select()">

                <label class="sr-only" for="search" data-role="minisearch-label">
                <span><?= $escaper->escapeHtml(__('Search')) ?></span>
            </label>

            <button
                type="submit"
                id="search-button"
                title="<?= $escaper->escapeHtml(__('Search')) ?>"
                class="px-3 lg:ml-1.5 text-gray-500 lg:block search order-2 lg:order-first"
                aria-label="<?= $escaper->escapeHtml(__('Search')) ?>">
                <?= $heroicons->searchHtml('text-primary', 20, 20, ['aria-hidden' => 'true']); ?>
            </button>

        </div>
        <template x-if="suggestions.length > 0">
            <div class="hidden absolute z-5 lg:flex flex-col w-full mt-2 leading-normal text-slate-800">
                <template x-for="suggestion in suggestions">
                    <div class="flex justify-between p-2 mb-1 border rounded-md cursor-pointer bg-container-lighter even:bg-container border-container hover:bg-container-darker"
                        tabindex="0"
                        @click="search(suggestion.title)"
                        @keydown.enter="search(suggestion.title)"
                        @keydown.arrow-up.prevent="
                              focusElement($event.target.previousElementSibling) || $refs.searchInput.focus()
                          "
                        @keydown.arrow-down.prevent="focusElement($event.target.nextElementSibling)">
                        <span x-text="suggestion.title"></span>
                        <span x-text="suggestion.num_results"></span>
                    </div>
                </template>
            </div>
        </template>
    </form>
</search>
